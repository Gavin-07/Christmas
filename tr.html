<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Grand Luxury Tree - Ultimate Edition</title>

  <style>
    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      overflow: hidden;
      background-color: #050505;
      font-family: 'Times New Roman', serif;
    }

    /* ËÉåÊôØÈõ™Ëä±Â±ÇÔºà2DÔºâ */
    #bg-overlay {
      position: absolute;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 2;
      pointer-events: none;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    /* ÂÖºÂÆπÊñ∞ÊµèËßàÂô®ÁöÑÂä®ÊÄÅÈ´òÂ∫¶ÔºåÂáèÂ∞ëÁßªÂä®Á´ØÈîô‰Ωç */
    @supports (height: 100svh) {
      #canvas-container,
      #bg-overlay {
        height: 100svh;
      }
    }

    /* UI Layer */
    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 3vh;
      box-sizing: border-box;
      background: transparent;
    }

    .ui-hidden {
      opacity: 0;
      pointer-events: none !important;
      transition: opacity 0.8s ease;
    }

    /* Loader */
    #loader {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 1.2s cubic-bezier(0.23, 1, 0.32, 1);
    }
    .loader-text {
      color: #d4af37;
      font-size: 12px;
      letter-spacing: 6px;
      margin-top: 25px;
      text-transform: uppercase;
      font-family: 'Cinzel', serif;
      animation: pulse 2s infinite;
    }
    .spinner {
      width: 50px;
      height: 50px;
      border: 2px solid rgba(212, 175, 55, 0.1);
      border-top: 2px solid #d4af37;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    /* Title */
    h1 {
      color: #fceea7;
      font-size: clamp(32px, 5vw, 64px);
      margin: 0;
      font-weight: 400;
      letter-spacing: 8px;
      text-shadow:
        0 0 40px rgba(252, 238, 167, 0.4),
        0 0 80px rgba(212, 175, 55, 0.2);
      background: linear-gradient(180deg, #ffffff 0%, #eebb66 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-family: 'Cinzel', serif;
      opacity: 0.95;
    }

    #file-input { display: none; }

    /* Â∑¶‰∏ãËßíÔºöBGM + ÊñáÊ°à */
    #bottom-left-panel {
      position: absolute;
      left: calc(16px + env(safe-area-inset-left));
      bottom: calc(20px + env(safe-area-inset-bottom));
      z-index: 20;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-start;
    }

    #bgm-toggle {
      pointer-events: auto;
      border-radius: 999px;
      border: 1px solid rgba(212, 175, 55, 0.7);
      background: rgba(10, 10, 10, 0.7);
      color: #f9e7b0;
      padding: 8px 18px;
      font-size: 12px;
      letter-spacing: 2px;
      font-family: 'Cinzel', serif;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.75);
      transition: all 0.25s ease;
    }
    #bgm-toggle:hover {
      background: #d4af37;
      color: #000;
      box-shadow:
        0 0 22px rgba(212, 176, 80, 0.5),
        0 0 50px rgba(0, 0, 0, 0.9);
      transform: translateY(-1px);
    }

    #instructions {
      color: rgba(255, 255, 255, 0.86);
      font-family: 'Cinzel', serif;
      pointer-events: none;
      text-align: left;
    }
    .inst-item {
      margin-bottom: 8px;
      font-size: 13px;
      display: flex;
      align-items: center;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
      letter-spacing: 1px;
    }
    .inst-icon {
      display: inline-flex;
      width: 32px;
      height: 32px;
      border: 1px solid rgba(212, 175, 55, 0.55);
      border-radius: 50%;
      align-items: center;
      justify-content: center;
      margin-right: 12px;
      background: rgba(0, 0, 0, 0.6);
      color: #d4af37;
      font-size: 16px;
      box-shadow: 0 0 10px rgba(212, 175, 55, 0.25);
    }

    /* Âè≥‰∏ãËßíÈ¢úËâ≤Áõò */
    #theme-panel {
      position: fixed;
      right: calc(16px + env(safe-area-inset-right));
      bottom: calc(20px + env(safe-area-inset-bottom));
      z-index: 30;
      pointer-events: auto;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(5, 5, 5, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      backdrop-filter: blur(6px);
    }
    .theme-dots {
      display: flex;
      gap: 8px;
    }
    .theme-btn {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.7);
      cursor: pointer;
      padding: 0;
      outline: none;
      background-size: 180% 180%;
      background-position: center;
      transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
    }
    .theme-btn.theme-active {
      transform: scale(1.15);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
      border-color: #fff;
    }

    .theme-gold {
      background-image: linear-gradient(135deg, #f6d48a, #f1b65c, #fef2cf);
    }
    .theme-ice {
      background-image: linear-gradient(135deg, #cfe2ff, #8aa8ff, #f7fbff);
    }
    .theme-purple {
      background-image: linear-gradient(135deg, #f1dfff, #b78ef3, #f6f1ff);
    }
    .theme-emerald {
      background-image: linear-gradient(135deg, #bff4cf, #3b8f63, #f3fff7);
    }
    .theme-rose {
      background-image: linear-gradient(135deg, #ffd4e1, #f08ab1, #fff0f5);
    }

    #webcam-wrapper,
    #webcam,
    #webcam-preview {
      display: none;
    }

    @media (max-width: 768px) {
      h1 {
        font-size: clamp(26px, 7vw, 34px);
        letter-spacing: 5px;
      }
      #bottom-left-panel {
        gap: 6px;
      }
      #bgm-toggle {
        padding: 6px 14px;
        font-size: 11px;
      }
      .inst-item { font-size: 11px; }
      .inst-icon {
        width: 26px;
        height: 26px;
        margin-right: 8px;
        font-size: 14px;
      }

      #theme-panel {
        padding: 4px 8px;
      }
      .theme-btn {
        width: 14px;
        height: 14px;
      }
    }
  </style>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&display=swap');
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
      }
    }
  </script>
</head>

<body>
  <div id="loader">
    <div class="spinner"></div>
    <div class="loader-text">MERRY CHRISTMAS</div>
  </div>

  <canvas id="bg-overlay"></canvas>
  <div id="canvas-container"></div>

  <div id="ui-layer">
    <h1>MERRY CHRISTMAS</h1>

    <div id="bottom-left-panel">
      <button id="bgm-toggle">
        <span>‚ô™</span><span>Èü≥‰πê ÂºÄ</span>
      </button>

      <div id="instructions">
        <div class="inst-item">
          <span class="inst-icon">‚úä</span>
          <span>Êè°Êã≥ ¬∑ ËÅöÊã¢ÊàêÊ†ë</span>
        </div>
        <div class="inst-item">
          <span class="inst-icon">üñê</span>
          <span>Âº†ÂºÄ ¬∑ Êï£ÊàêÊòüÊµ∑</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Âè≥‰∏ãËßíÈ¢úËâ≤Áõò -->
  <div id="theme-panel">
    <div class="theme-dots">
      <button class="theme-btn theme-gold theme-active" data-theme="0"></button>
      <button class="theme-btn theme-ice"                 data-theme="1"></button>
      <button class="theme-btn theme-purple"              data-theme="2"></button>
      <button class="theme-btn theme-emerald"             data-theme="3"></button>
      <button class="theme-btn theme-rose"                data-theme="4"></button>
    </div>
  </div>

  <div id="webcam-wrapper">
    <video id="webcam" autoplay playsinline></video>
    <canvas id="webcam-preview"></canvas>
  </div>

  <audio id="bgm" loop src="./christmas-bgm.m4a"></audio>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import {
      FilesetResolver,
      HandLandmarker,
      DrawingUtils
    } from '@mediapipe/tasks-vision';

    const IS_MOBILE = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    /* ========= ‰∏ªÈ¢òÈÖçËâ≤ ========== */
    const THEMES = [
      {
        label: 'GOLD',
        bg: 0x050309,
        overlay: [
          'rgba(40,32,18,0.22)',
          'rgba(6,6,10,0.18)',
          'rgba(90,55,24,0.16)'
        ],
        bulbA: 0xf7d58a,
        bulbB: 0xfff3cf,
        bulbEmissive: 0x604322,
        accentA: 0xf8e9cf,
        accentB: 0xe2c89a,
        accentEmissive: 0x3e2914,
        green: 0x14301c,
        red: 0x8f3b32,
        dust: 0xfff8e6,
        garlandA: 0xf5e0b5,
        garlandB: 0xe0c18d,
        garlandEmissive: 0x6b4a26,
        starA: 0xfff4ce,
        starB: 0xffdd9a,
        starEmissive: 0xe7b86a,
        haloA: 0xffe2a0,
        bgStarA: 0xc0c7df
      },
      {
        label: 'ICE',
        bg: 0x050914,
        overlay: [
          'rgba(46,86,140,0.18)',
          'rgba(7,13,28,0.16)',
          'rgba(18,56,120,0.18)'
        ],
        bulbA: 0xd7e5ff,
        bulbB: 0xf7fbff,
        bulbEmissive: 0x304a7a,
        accentA: 0xf1f5ff,
        accentB: 0xd0ddff,
        accentEmissive: 0x23365a,
        green: 0x142438,
        red: 0x5c91ff,
        dust: 0xf5f8ff,
        garlandA: 0xd6e6ff,
        garlandB: 0xadc5f5,
        garlandEmissive: 0x3b5993,
        starA: 0xf1f7ff,
        starB: 0xc7ddff,
        starEmissive: 0xa3c9ff,
        haloA: 0xb9d5ff,
        bgStarA: 0xa7baf5
      },
      {
        label: 'PURPLE',
        bg: 0x07020f,
        overlay: [
          'rgba(102,68,152,0.20)',
          'rgba(18,8,36,0.16)',
          'rgba(210,164,255,0.16)'
        ],
        bulbA: 0xe7dcff,
        bulbB: 0xfaf7ff,
        bulbEmissive: 0x5b3a8e,
        accentA: 0xf8efe0,
        accentB: 0xe1c89a,
        accentEmissive: 0x3b2614,
        green: 0x22142f,
        red: 0xf2c99b,
        dust: 0xfdf7ff,
        garlandA: 0xe9d9ff,
        garlandB: 0xd4b6f4,
        garlandEmissive: 0x6b3b8d,
        starA: 0xfff5e7,
        starB: 0xe6c9ff,
        starEmissive: 0xf3c99c,
        haloA: 0xf2d9ff,
        bgStarA: 0xdcc5ff
      },
      {
        label: 'EMERALD',
        bg: 0x030806,
        overlay: [
          'rgba(42,96,72,0.18)',
          'rgba(5,18,14,0.15)',
          'rgba(24,84,52,0.18)'
        ],
        bulbA: 0xcff9db,
        bulbB: 0xf4fff9,
        bulbEmissive: 0x29573f,
        accentA: 0xf8edd5,
        accentB: 0xd9c29a,
        accentEmissive: 0x47311b,
        green: 0x184635,
        red: 0xc0a47c,
        dust: 0xf7fff9,
        garlandA: 0xd3ffd7,
        garlandB: 0xa8f3c2,
        garlandEmissive: 0x3b7a52,
        starA: 0xf4ffe9,
        starB: 0xd1f7bf,
        starEmissive: 0xb4f39a,
        haloA: 0xc9ffb1,
        bgStarA: 0xa2f3cf
      },
      {
        label: 'ROSE',
        bg: 0x12040a,
        overlay: [
          'rgba(128,54,86,0.18)',
          'rgba(20,10,18,0.15)',
          'rgba(170,78,112,0.18)'
        ],
        bulbA: 0xfad0da,
        bulbB: 0xfff4f7,
        bulbEmissive: 0x874758,
        accentA: 0xffe6d8,
        accentB: 0xf5c9aa,
        accentEmissive: 0x5b3526,
        green: 0x3a1a25,
        red: 0xe58aa5,
        dust: 0xfff5f7,
        garlandA: 0xffd1de,
        garlandB: 0xf4a9c2,
        garlandEmissive: 0x8d455a,
        starA: 0xfff0e6,
        starB: 0xf8d1e0,
        starEmissive: 0xf0a5bf,
        haloA: 0xf7dae5,
        bgStarA: 0xf2b4cf
      }
    ];

    const MATERIALS = {
      goldMat: null,
      champagneMat: null,
      greenMat: null,
      redMat: null,
      dustMat: null,
      garlandMats: [],
      starMat: null
    };
    let bgStarMaterial = null;

    let currentThemeIndex = 0;

    const CONFIG = {
      colors: {
        bg: 0x020202,
        gold: 0xffd700,
        champagne: 0xffeec0,
        green: 0x0a2a12,
        red: 0x880000
      },
      particles: {
        count: 2600,
        dustCount: 2300,
        treeHeight: 28,
        treeRadius: 9
      },
      camera: {
        z: 55
      }
    };

    const STATE = {
      mode: 'TREE',
      hand: { detected: false, x: 0, y: 0 },
      mouse: { x: 0, y: 0 },
      rotation: { x: 0, y: 0 },
      time: 0,
      starMesh: null
    };

    let scene, camera, renderer, composer;
    let mainGroup, starGroup, bgGroup;
    let clock = new THREE.Clock();
    let particleSystem = [];
    let garlandHolders = [];
    let photoMeshGroup = new THREE.Group();

    let handLandmarker, video;
    let caneTexture;
    let drawingUtils, canvasCtx;

    let overlayCanvas, overlayCtx;
    let overlayW = 0, overlayH = 0;
    let snowflakes = [];
    let bokehLights = [];
    let snowflakeSprite = null;

    function applyTheme(index) {
      currentThemeIndex = index;
      const t = THEMES[index];

      if (scene) {
        scene.background.setHex(t.bg);
        if (scene.fog) scene.fog.color.setHex(t.bg);
      }

      if (MATERIALS.goldMat) {
        MATERIALS.goldMat.color.setHex(t.bulbA);
        MATERIALS.goldMat.emissive.setHex(t.bulbEmissive);
        MATERIALS.goldMat.needsUpdate = true;
      }
      if (MATERIALS.champagneMat) {
        MATERIALS.champagneMat.color.setHex(t.accentA);
        MATERIALS.champagneMat.emissive.setHex(t.accentEmissive);
        MATERIALS.champagneMat.needsUpdate = true;
      }
      if (MATERIALS.greenMat) {
        MATERIALS.greenMat.color.setHex(t.green);
        MATERIALS.greenMat.needsUpdate = true;
      }
      if (MATERIALS.redMat) {
        MATERIALS.redMat.color.setHex(t.red);
        MATERIALS.redMat.needsUpdate = true;
      }
      if (MATERIALS.dustMat) {
        MATERIALS.dustMat.color.setHex(t.dust);
        MATERIALS.dustMat.needsUpdate = true;
      }
      MATERIALS.garlandMats.forEach((mat, idx) => {
        const c = idx === 0 ? t.garlandA : t.garlandB;
        mat.color.setHex(c);
        mat.emissive.setHex(t.garlandEmissive);
        mat.needsUpdate = true;
      });
      if (MATERIALS.starMat) {
        MATERIALS.starMat.color.setHex(t.starA);
        MATERIALS.starMat.emissive.setHex(t.starEmissive);
        MATERIALS.starMat.needsUpdate = true;
      }
      if (bgStarMaterial) {
        bgStarMaterial.color.setHex(t.bgStarA);
        bgStarMaterial.needsUpdate = true;
      }
    }

    async function init() {
      initThree();
      initOverlay();
      setupEnvironment();
      setupLights();
      createTextures();
      createBackgroundStars();
      createParticles();
      createGarlands();
      setupPostProcessing();
      setupEvents();
      setupBGM();
      setupThemeUI();
      applyTheme(currentThemeIndex);
      initMediaPipe().catch(console.warn);

      const loader = document.getElementById('loader');
      loader.style.opacity = 0;
      setTimeout(() => loader.remove(), 1200);

      animate();
    }

    function setRendererPixelRatio() {
      const dpr = window.devicePixelRatio || 1;
      const maxDpr = IS_MOBILE ? 3.5 : 3;   // ÁßªÂä®Á´ØÂÜçÈ´ò‰∏ÄÁÇπ
      const target = Math.min(dpr * (IS_MOBILE ? 1.1 : 1.0), maxDpr);
      renderer.setPixelRatio(target);
    }

    function initThree() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.colors.bg);
      scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.00015);

      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );
      camera.position.set(0, 0, CONFIG.camera.z);

      renderer = new THREE.WebGLRenderer({
        antialias: true,      // ÊâìÂºÄÊäóÈîØÈΩøÔºåËÆ©ËæπÁºòÊõ¥ÁªÜËÖª
        powerPreference: 'high-performance',
        stencil: false,
        depth: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      setRendererPixelRatio();
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.48;  // Áï•ÂæÆÊèê‰∫Æ‰∏ÄÁÇπ
      const containerEl = document.getElementById('canvas-container');
      containerEl.appendChild(renderer.domElement);

      bgGroup = new THREE.Group();
      scene.add(bgGroup);

      mainGroup = new THREE.Group();
      mainGroup.rotation.x = 0.1;
      mainGroup.position.y = -2.5;
      scene.add(mainGroup);

      starGroup = new THREE.Group();
      mainGroup.add(starGroup);
    }

    /* ========== Ë¶ÜÁõñÂ±ÇÔºöËΩªÂæÆÊöóËßí + Èõ™Ëä± ========== */
    function initOverlay() {
      overlayCanvas = document.getElementById('bg-overlay');
      overlayCtx = overlayCanvas.getContext('2d');

      function resizeOverlay() {
        overlayW = window.innerWidth;
        overlayH = window.innerHeight;
        overlayCanvas.width = overlayW;
        overlayCanvas.height = overlayH;
      }
      resizeOverlay();
      window.addEventListener('resize', resizeOverlay);

      const snowCount = 110;
      snowflakes = [];
      for (let i = 0; i < snowCount; i++) {
        snowflakes.push({
          x: Math.random() * overlayW,
          y: Math.random() * overlayH,
          size: 10 + Math.random() * 22,
          speed: 20 + Math.random() * 30,
          drift: -20 + Math.random() * 40,
          phase: Math.random() * Math.PI * 2,
          rotation: Math.random() * Math.PI * 2,
          spin: Math.random() * 0.5 - 0.25
        });
      }

      const bokehCount = 5;
      bokehLights = [];
      for (let i = 0; i < bokehCount; i++) {
        bokehLights.push({
          x: Math.random() * overlayW,
          y: Math.random() * overlayH,
          r: 120 + Math.random() * 120,
          baseAlpha: 0.006 + Math.random() * 0.006,
          phase: Math.random() * Math.PI * 2,
          driftX: -4 + Math.random() * 8,
          driftY: -3 + Math.random() * 6
        });
      }

      snowflakeSprite = createSnowflakeSprite();
    }

    function renderOverlay(dt) {
      if (!overlayCtx) return;
      const w = overlayW, h = overlayH;
      overlayCtx.clearRect(0, 0, w, h);

      // ËΩªÂæÆÊöóËßí
      overlayCtx.save();
      const vignette = overlayCtx.createRadialGradient(
        w / 2, h * 0.45, 0,
        w / 2, h * 0.45, Math.max(w, h) * 0.9
      );
      vignette.addColorStop(0, 'rgba(0,0,0,0)');
      vignette.addColorStop(1, 'rgba(0,0,0,0.12)');
      overlayCtx.fillStyle = vignette;
      overlayCtx.fillRect(0, 0, w, h);
      overlayCtx.restore();

      // Êï£ÊôØ
      overlayCtx.save();
      overlayCtx.globalCompositeOperation = 'lighter';
      bokehLights.forEach(b => {
        b.x += b.driftX * dt;
        b.y += b.driftY * dt;
        if (b.x < -b.r) b.x = w + b.r;
        if (b.x > w + b.r) b.x = -b.r;
        if (b.y < -b.r) b.y = h + b.r;
        if (b.y > h + b.r) b.y = -b.r;

        const alpha = b.baseAlpha + Math.sin(STATE.time * 0.4 + b.phase) * 0.004;
        const radial = overlayCtx.createRadialGradient(
          b.x, b.y, 0, b.x, b.y, b.r
        );
        radial.addColorStop(0, `rgba(255,255,255,${alpha * 1.5})`);
        radial.addColorStop(1, 'rgba(255,255,255,0)');
        overlayCtx.fillStyle = radial;
        overlayCtx.beginPath();
        overlayCtx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        overlayCtx.fill();
      });
      overlayCtx.restore();

      // Èõ™Ëä±
      overlayCtx.save();
      const img = snowflakeSprite;
      snowflakes.forEach(s => {
        s.y += s.speed * dt;
        s.x += Math.sin(STATE.time * 0.7 + s.phase) * (s.drift * dt);
        s.rotation += s.spin * dt;

        const maxY = h + s.size;
        if (s.y > maxY) {
          s.y = -s.size;
          s.x = Math.random() * w;
        }

        if (img) {
          overlayCtx.save();
          overlayCtx.translate(s.x, s.y);
          overlayCtx.rotate(s.rotation);
          const scale = s.size / img.width;
          overlayCtx.scale(scale, scale);
          overlayCtx.globalAlpha =
            0.25 + 0.25 * Math.sin(STATE.time * 1.5 + s.phase);
          overlayCtx.drawImage(img, -img.width / 2, -img.height / 2);
          overlayCtx.restore();
        } else {
          overlayCtx.fillStyle = 'rgba(255,255,255,0.8)';
          overlayCtx.beginPath();
          overlayCtx.arc(s.x, s.y, s.size * 0.3, 0, Math.PI * 2);
          overlayCtx.fill();
        }
      });
      overlayCtx.restore();
    }

    function createSnowflakeSprite() {
      const size = 48;
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');

      ctx.clearRect(0, 0, size, size);
      ctx.translate(size / 2, size / 2);
      ctx.strokeStyle = 'rgba(255,255,255,0.98)';
      ctx.lineWidth = 1.4;
      ctx.lineCap = 'round';

      const arms = 6;
      const radius = size * 0.35;
      const branchOffset = Math.PI / 8;

      for (let i = 0; i < arms; i++) {
        const angle = (Math.PI * 2 * i) / arms;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);

        ctx.beginPath();
        ctx.moveTo(cos * radius * 0.12, sin * radius * 0.12);
        ctx.lineTo(cos * radius, sin * radius);
        ctx.stroke();

        const baseR = radius * 0.55;
        [baseR * 0.75, baseR].forEach(r => {
          const bx = cos * r;
          const by = sin * r;

          ctx.beginPath();
          ctx.moveTo(bx, by);
          ctx.lineTo(
            bx + Math.cos(angle + branchOffset) * radius * 0.25,
            by + Math.sin(angle + branchOffset) * radius * 0.25
          );
          ctx.moveTo(bx, by);
          ctx.lineTo(
            bx + Math.cos(angle - branchOffset) * radius * 0.25,
            by + Math.sin(angle - branchOffset) * radius * 0.25
          );
          ctx.stroke();
        });
      }

      return c;
    }

    /* È°∂ÈÉ®ÊòüÊòüÁî®ÁöÑÊú¨Âú∞ÂÖâÊôïÁ∫πÁêÜÔºåÊõø‰ª£Â§ñÈìæ glow.png */
    function createGlowTexture() {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');

      const grad = ctx.createRadialGradient(
        size / 2, size / 2, 0,
        size / 2, size / 2, size / 2
      );
      grad.addColorStop(0.0, 'rgba(255,255,255,1.0)');
      grad.addColorStop(0.35, 'rgba(255,230,170,0.95)');
      grad.addColorStop(0.7, 'rgba(255,230,170,0.35)');
      grad.addColorStop(1.0, 'rgba(255,230,170,0.0)');

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    function setupEnvironment() {
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();
      scene.environment = pmremGenerator.fromScene(
        new RoomEnvironment(),
        0.04
      ).texture;
    }

    function setupLights() {
      const ambient = new THREE.AmbientLight(0xffffff, 0.22);
      scene.add(ambient);

      const bottomLight = new THREE.PointLight(CONFIG.colors.gold, 2.2, 40);
      bottomLight.position.set(0, -10, 10);
      mainGroup.add(bottomLight);

      const spotGold = new THREE.SpotLight(0xfff0dd, 450);
      spotGold.position.set(40, 60, 40);
      spotGold.angle = 0.4;
      spotGold.penumbra = 0.5;
      spotGold.decay = 2;
      spotGold.distance = 200;
      scene.add(spotGold);

      const spotBlue = new THREE.SpotLight(0x4455ff, 220);
      spotBlue.position.set(-40, 10, -30);
      spotBlue.lookAt(0, 0, 0);
      scene.add(spotBlue);
    }

    function setupPostProcessing() {
      const renderScene = new RenderPass(scene, camera);
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.65,   // Áï•ÂæÆÂáè‰∏ÄÁÇπ BloomÔºåÊèêÈ´ò‚ÄúÊ∏ÖÊô∞ÊÑü‚Äù
        0.3,
        1.0
      );
      composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);
    }

    function createTextures() {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, 128, 128);
      ctx.fillStyle = '#aa0000';
      ctx.beginPath();
      for (let i = -128; i < 256; i += 32) {
        ctx.moveTo(i, 0);
        ctx.lineTo(i + 32, 128);
        ctx.lineTo(i + 16, 128);
        ctx.lineTo(i - 16, 0);
      }
      ctx.fill();

      caneTexture = new THREE.CanvasTexture(canvas);
      caneTexture.colorSpace = THREE.SRGBColorSpace;
      caneTexture.wrapS = THREE.RepeatWrapping;
      caneTexture.wrapT = THREE.RepeatWrapping;
      caneTexture.repeat.set(3, 3);
    }

    function createBackgroundStars() {
      const geometry = new THREE.BufferGeometry();
      const count = 900;
      const positions = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        const r = 80 + Math.random() * 100;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = r * Math.cos(phi);
      }

      geometry.setAttribute(
        'position',
        new THREE.BufferAttribute(positions, 3)
      );
      const material = new THREE.PointsMaterial({
        color: THEMES[currentThemeIndex].bgStarA,
        size: 0.9,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true
      });

      bgStarMaterial = material;

      const points = new THREE.Points(geometry, material);
      bgGroup.add(points);
    }

    class Particle {
      constructor(mesh, type, isDust = false) {
        this.mesh = mesh;
        this.type = type;
        this.isDust = isDust;

        this.posTree = new THREE.Vector3();
        this.posScatter = new THREE.Vector3();
        this.baseScale = mesh.scale.x;

        this.offset = Math.random() * 100;
        this.speed = 0.6 + Math.random();

        if (mesh.material && mesh.material.emissive) {
          this.baseEmissive = mesh.material.emissive.clone();
          this.hasEmissive = true;
        }

        this.calculatePositions();
      }

      calculatePositions() {
        const h = CONFIG.particles.treeHeight;
        const halfH = h / 2;
        const isSpiral = Math.random() > 0.7 && !this.isDust;

        let t = Math.random();

        if (isSpiral) {
          const y = t * h - halfH;
          const rBase = CONFIG.particles.treeRadius * (1.0 - t);
          const revolutions = 7;
          const angle = t * Math.PI * 2 * revolutions;
          this.posTree.set(
            Math.cos(angle) * rBase,
            y,
            Math.sin(angle) * rBase
          );
        } else {
          t = Math.pow(t, 0.8);
          const y = t * h - halfH;
          let rMax = CONFIG.particles.treeRadius * (1.0 - t);
          if (rMax < 0.5) rMax = 0.5;
          const angle = Math.random() * Math.PI * 2;
          const r = rMax * Math.sqrt(Math.random());
          this.posTree.set(
            Math.cos(angle) * r,
            y,
            Math.sin(angle) * r
          );
        }

        let rScatter = this.isDust ? 15 + Math.random() * 25 : 10 + Math.random() * 15;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        this.posScatter.set(
          rScatter * Math.sin(phi) * Math.cos(theta),
          rScatter * Math.sin(phi) * Math.sin(theta),
          rScatter * Math.cos(phi)
        );
      }

      update(dt, time, mode) {
        const target = mode === 'SCATTER' ? this.posScatter : this.posTree;

        const noiseY = Math.sin(time * this.speed + this.offset) * 0.15;
        const noiseX = Math.cos(time * 0.5 * this.speed + this.offset) * 0.1;

        const dest = target.clone();
        if (mode === 'TREE') {
          dest.y += noiseY;
          dest.x += noiseX;
        }

        const lerpSpeed = 2.8;
        this.mesh.position.lerp(dest, lerpSpeed * dt);

        if (mode === 'SCATTER' || this.isDust) {
          this.mesh.rotation.x += dt * 0.55;
          this.mesh.rotation.y += dt * 0.35;
        } else if (mode === 'TREE') {
          this.mesh.rotation.y += dt * 0.12;
        }

        if (this.hasEmissive && mode === 'TREE' && !this.isDust) {
          const blink = Math.sin(time * 2.3 + this.offset);
          this.mesh.material.emissiveIntensity =
            0.16 + Math.max(0, blink) * 0.4;
        }

        let s = this.baseScale;
        if (this.isDust) {
          s = this.baseScale *
              (0.5 + 0.5 * Math.sin(time * 3 + this.offset));
        } else if (mode === 'SCATTER') {
          s = this.baseScale * 1.1;
        }

        this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 5 * dt);
      }
    }

    function createParticles() {
      const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32);
      const icosaGeo = new THREE.IcosahedronGeometry(0.45, 0);
      const boxGeo = new THREE.BoxGeometry(0.45, 0.45, 0.45);

      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, -0.5, 0),
        new THREE.Vector3(0, 0.3, 0),
        new THREE.Vector3(0.1, 0.5, 0),
        new THREE.Vector3(0.3, 0.4, 0)
      ]);
      const candyGeo = new THREE.TubeGeometry(
        curve,
        16,
        0.08,
        8,
        false
      );

      const goldMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.gold,
        metalness: 1.0,
        roughness: 0.2,
        envMapIntensity: 1.7,
        emissive: 0x553300,
        emissiveIntensity: 0.14
      });

      const champagneMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.champagne,
        metalness: 0.9,
        roughness: 0.24,
        envMapIntensity: 1.6,
        emissive: 0x332211,
        emissiveIntensity: 0.12
      });

      const greenMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.green,
        metalness: 0.45,
        roughness: 0.3,
        emissive: 0x001100,
        emissiveIntensity: 0.1
      });

      const redMat = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.red,
        metalness: 0.6,
        roughness: 0.22,
        clearcoat: 0.9,
        clearcoatRoughness: 0.15,
        emissive: 0x330000,
        emissiveIntensity: 0.22
      });

      const candyMat = new THREE.MeshStandardMaterial({
        map: caneTexture,
        roughness: 0.28,
        metalness: 0.1,
        emissive: 0x222222
      });

      const dustGeo = new THREE.OctahedronGeometry(0.1, 0);
      const dustMat = new THREE.MeshBasicMaterial({
        color: 0xfffbe0,
        blending: THREE.AdditiveBlending
      });

      MATERIALS.goldMat = goldMat;
      MATERIALS.champagneMat = champagneMat;
      MATERIALS.greenMat = greenMat;
      MATERIALS.redMat = redMat;
      MATERIALS.dustMat = dustMat;

      for (let i = 0; i < CONFIG.particles.count; i++) {
        const rand = Math.random();
        let mesh, type;

        if (rand < 0.25) {
          mesh = new THREE.Mesh(boxGeo, greenMat);
          type = 'BOX';
        } else if (rand < 0.55) {
          mesh = new THREE.Mesh(boxGeo, champagneMat);
          type = 'CHAMP_BOX';
        } else if (rand < 0.8) {
          mesh = new THREE.Mesh(sphereGeo, goldMat);
          type = 'GOLD_SPHERE';
        } else if (rand < 0.94) {
          mesh = new THREE.Mesh(icosaGeo, champagneMat);
          type = 'ICOSA';
        } else if (rand < 0.98) {
          mesh = new THREE.Mesh(sphereGeo, redMat);
          type = 'RED';
        } else {
          mesh = new THREE.Mesh(candyGeo, candyMat);
          type = 'CANE';
        }

        const s = 0.24 + Math.random() * 0.32;
        mesh.scale.set(s, s, s);
        mesh.rotation.set(
          Math.random() * 6,
          Math.random() * 6,
          Math.random() * 6
        );

        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, type, false));
      }

      for (let i = 0; i < CONFIG.particles.dustCount; i++) {
        const mesh = new THREE.Mesh(dustGeo, dustMat);
        mesh.scale.setScalar(0.5 + Math.random());
        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, 'DUST', true));
      }

      createStarTopper();
      mainGroup.add(photoMeshGroup);
    }

    function createGarlands() {
      const h = CONFIG.particles.treeHeight;
      const halfH = h / 2;

      const levels = [0.45, 0.70];

      levels.forEach((t, idx) => {
        const y = t * h - halfH;

        const baseRadius = CONFIG.particles.treeRadius * (1.0 - t);
        const radius =
          idx === 0
            ? baseRadius * 0.55 + 0.15
            : baseRadius * 0.65 + 0.25;

        const geo = new THREE.TorusGeometry(
          radius,
          0.045,
          24,
          220
        );
        const mat = new THREE.MeshStandardMaterial({
          color: 0xfff0c4,
          metalness: 0.95,
          roughness: 0.25,
          emissive: 0x775522,
          emissiveIntensity: 0.14,
          transparent: true,
          opacity: 0.12
        });

        MATERIALS.garlandMats.push(mat);

        const ring = new THREE.Mesh(geo, mat);

        const tiltDeg = idx === 0 ? 10 : 18;
        const tiltRad = THREE.MathUtils.degToRad(tiltDeg);
        ring.rotation.z = tiltRad;

        const holder = new THREE.Group();
        holder.position.y = y;
        holder.add(ring);

        mainGroup.add(holder);
        garlandHolders.push(holder);
      });
    }

    function createStarTopper() {
      const shape = new THREE.Shape();
      const arms = 6;
      const outerR = 1.8;
      const innerR = 0.7;

      for (let i = 0; i < arms * 2; i++) {
        const r = i % 2 === 0 ? outerR : innerR;
        const angle = (i / (arms * 2)) * Math.PI * 2 - Math.PI / 2;
        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        if (i === 0) shape.moveTo(x, y);
        else shape.lineTo(x, y);
      }
      shape.closePath();

      const extrudeSettings = {
        depth: 0.5,
        bevelEnabled: true,
        bevelThickness: 0.18,
        bevelSize: 0.22,
        bevelSegments: 4
      };

      const starGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      starGeo.center();

      const starMat = new THREE.MeshPhysicalMaterial({
        color: 0xfff3c0,
        metalness: 1.0,
        roughness: 0.12,
        clearcoat: 1.0,
        clearcoatRoughness: 0.05,
        emissive: 0xffd890,
        emissiveIntensity: 0.8,
        reflectivity: 1.0
      });

      MATERIALS.starMat = starMat;

      const star = new THREE.Mesh(starGeo, starMat);
      star.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0);
      star.rotation.set(0, Math.PI, 0);
      star.castShadow = true;

      // ‰ΩøÁî®Êú¨Âú∞ÁîüÊàêÁöÑ glow Á∫πÁêÜÔºåÂÖâÊôïÁï•Â∞è„ÄÅÁï•Êüî
      const glowTex = createGlowTexture();
      const haloMat = new THREE.SpriteMaterial({
        map: glowTex,
        color: 0xffe6aa,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.2     // ‰πãÂâç 0.26ÔºåÁ®çÂæÆÊõ¥ËΩª‰∏ÄÁÇπ
      });
      const halo = new THREE.Sprite(haloMat);
      halo.scale.set(5, 5, 5);   // ‰πãÂâç 7 ‚Üí ÂÖâÊôïÊõ¥Â∞è
      star.add(halo);

      starGroup.add(star);
      STATE.starMesh = star;
    }

    async function initMediaPipe() {
      const vision = await FilesetResolver.forVisionTasks(
        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm'
      );
      handLandmarker = await HandLandmarker.createFromOptions(
        vision,
        {
          baseOptions: {
            modelAssetPath:
              'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
            delegate: 'GPU'
          },
          runningMode: 'VIDEO',
          numHands: 1
        }
      );

      video = document.getElementById('webcam');
      const canvasElement = document.getElementById('webcam-preview');
      canvasCtx = canvasElement.getContext('2d');
      drawingUtils = new DrawingUtils(canvasCtx);

      if (navigator.mediaDevices?.getUserMedia) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720 }
          });
          video.srcObject = stream;
          video.addEventListener('loadeddata', () => {
            predictWebcam();
          });
        } catch (e) {
          console.warn('Webcam access denied', e);
          alert('ËØ∑ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥ÊùÉÈôê‰ª•‰ΩìÈ™åÊâãÂäø‰∫íÂä®ÂäüËÉΩ');
        }
      }
    }

    let lastVideoTime = -1;
    async function predictWebcam() {
      const canvasElement = document.getElementById('webcam-preview');
      if (video.videoWidth && canvasElement.width !== video.videoWidth) {
        canvasElement.width = video.videoWidth;
        canvasElement.height = video.videoHeight;
      }

      if (lastVideoTime !== video.currentTime) {
        lastVideoTime = video.currentTime;

        let result = null;
        if (handLandmarker) {
          result = handLandmarker.detectForVideo(
            video,
            performance.now()
          );
        }

        canvasCtx.save();
        canvasCtx.drawImage(
          video,
          0,
          0,
          canvasElement.width,
          canvasElement.height
        );

        if (result && result.landmarks && result.landmarks.length > 0) {
          for (const landmarks of result.landmarks) {
            drawingUtils.drawConnectors(
              landmarks,
              HandLandmarker.HAND_CONNECTIONS,
              { color: '#d4af37', lineWidth: 3 }
            );
            drawingUtils.drawLandmarks(landmarks, {
              color: '#ffffff',
              lineWidth: 1,
              radius: 3
            });
          }
          processGestures(result.landmarks[0]);
        } else {
          STATE.hand.detected = false;
        }
        canvasCtx.restore();
      }
      requestAnimationFrame(predictWebcam);
    }

    function processGestures(lm) {
      STATE.hand.detected = true;

      const targetX = (lm[9].x - 0.5) * 2;
      const targetY = (lm[9].y - 0.5) * 2;
      STATE.hand.x += (targetX - STATE.hand.x) * 0.2;
      STATE.hand.y += (targetY - STATE.hand.y) * 0.2;

      const wrist = lm[0];
      const tips = [lm[8], lm[12], lm[16], lm[20]];
      let spread = 0;
      tips.forEach(t => {
        spread += Math.hypot(t.x - wrist.x, t.y - wrist.y);
      });
      spread /= tips.length;

      const TO_TREE = 0.33;
      const TO_SCATTER = 0.42;

      if (STATE.mode === 'SCATTER' && spread < TO_TREE) {
        STATE.mode = 'TREE';
      } else if (STATE.mode === 'TREE' && spread > TO_SCATTER) {
        STATE.mode = 'SCATTER';
      }
    }

    function setupEvents() {
      window.addEventListener('resize', () => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
        setRendererPixelRatio();      // ÊóãËΩ¨Â±èÂπïÊó∂ÈáçÊñ∞Êåâ DPR ËÆæÁΩÆÊ∏ÖÊô∞Â∫¶
        composer.setSize(w, h);
      });

      window.addEventListener('keydown', e => {
        if (e.key.toLowerCase() === 'h') {
          document
            .getElementById('ui-layer')
            .classList.toggle('ui-hidden');
        }
      });

      document.addEventListener('mousemove', e => {
        if (STATE.hand.detected) return;
        const x = (e.clientX / window.innerWidth) * 2 - 1;
        const y = -(e.clientY / window.innerHeight) * 2 + 1;
        STATE.mouse.x = x;
        STATE.mouse.y = y;
      });

      document.addEventListener(
        'touchmove',
        e => {
          if (STATE.hand.detected) return;
          const t = e.touches[0];
          const x = (t.clientX / window.innerWidth) * 2 - 1;
          const y = -(t.clientY / window.innerHeight) * 2 + 1;
          STATE.mouse.x = x;
          STATE.mouse.y = y;
        },
        { passive: true }
      );
    }

    function setupThemeUI() {
      const buttons = document.querySelectorAll('.theme-btn');
      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          const idx = parseInt(btn.dataset.theme, 10);
          applyTheme(idx);
          buttons.forEach(b => b.classList.remove('theme-active'));
          btn.classList.add('theme-active');
        });
      });
    }

    function setupBGM() {
      const bgm = document.getElementById('bgm');
      const btn = document.getElementById('bgm-toggle');
      let on = false;

      const updateLabel = () => {
        btn.querySelector('span:nth-child(2)').textContent = on ? 'Èü≥‰πê ÂÖ≥' : 'Èü≥‰πê ÂºÄ';
      };

      btn.addEventListener('click', () => {
        if (!on) {
          bgm
            .play()
            .then(() => {
              on = true;
              updateLabel();
            })
            .catch(e => {
              console.warn('BGM Êí≠ÊîæÂ§±Ë¥•ÔºàÂèØËÉΩË¢´ÊµèËßàÂô®ÈòªÊ≠¢ÔºâÔºö', e);
            });
        } else {
          bgm.pause();
          on = false;
          updateLabel();
        }
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      STATE.time = clock.elapsedTime;

      let inputX = STATE.hand.detected
        ? STATE.hand.x
        : STATE.mouse.x * 0.5;
      let inputY = STATE.hand.detected
        ? STATE.hand.y
        : STATE.mouse.y * 0.5;

      if (STATE.mode === 'TREE') {
        STATE.rotation.y += 0.2 * dt;
        mainGroup.rotation.z = THREE.MathUtils.lerp(
          mainGroup.rotation.z,
          inputX * 0.1,
          dt * 2
        );
        mainGroup.rotation.x =
          0.1 +
          THREE.MathUtils.lerp(
            0,
            inputY * 0.1,
            dt * 2
          );
      } else if (STATE.mode === 'SCATTER') {
        STATE.rotation.y +=
          (inputX * 2 - STATE.rotation.y) * 2 * dt;
        STATE.rotation.x +=
          (inputY * 0.5 - STATE.rotation.x) * 2 * dt;
      }

      mainGroup.rotation.y = STATE.rotation.y;

      bgGroup.rotation.y -= 0.05 * dt;
      bgGroup.rotation.z += 0.02 * dt;

      if (STATE.starMesh) {
        const s = 0.96 + Math.sin(STATE.time * 1.8) * 0.05;
        STATE.starMesh.scale.set(s, s, s);
      }

      garlandHolders.forEach((holder, idx) => {
        holder.rotation.y += (idx % 2 === 0 ? 0.10 : -0.06) * dt;
        const ring = holder.children[0];
        if (ring && ring.material) {
          ring.material.emissiveIntensity =
            0.14 + Math.sin(STATE.time * 1.2 + idx) * 0.08;
        }
      });

      particleSystem.forEach(p =>
        p.update(dt, STATE.time, STATE.mode)
      );

      renderOverlay(dt);
      composer.render();
    }

    init();
  </script>
</body>
</html>
